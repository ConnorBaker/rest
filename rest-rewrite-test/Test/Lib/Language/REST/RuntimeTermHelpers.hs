{-# LANGUAGE AllowAmbiguousTypes #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE ImplicitParams #-}

{-# LANGUAGE RankNTypes #-}

module Test.Lib.Language.REST.RuntimeTermHelpers where

import Data.Hashable (Hashable)

import qualified Data.HashSet as S
import Language.REST.Core (orient)
import Language.REST.ExploredTerms (
    ExploreStrategy (ExploreWhenNeeded),
 )
import Language.REST.RewriteRule
import Language.REST.Internal.Rewrite
import Language.REST.Internal.WorkStrategy (notVisitedFirst)
import Language.REST.OCAlgebra (OCAlgebra (isSat))
import Language.REST.Rest
import Language.REST.RuntimeTerm (RuntimeTerm)

-- | 'canOrient' returns true iff the ordering constraint algebra permits an ordering
--   that orients, the path, i.e., the constraints generated by 'orient' are satisfiable.
canOrient :: forall oc m . Show oc
  => (?impl :: OCAlgebra oc RuntimeTerm m) => [RuntimeTerm] -> m Bool
canOrient terms = isSat ?impl (orient ?impl terms)

diverges :: (Show oc) => OCAlgebra oc RuntimeTerm IO -> [RuntimeTerm] -> IO Bool
diverges impl ts = not <$> isSat impl (orient impl ts)

eval :: S.HashSet Rewrite -> RuntimeTerm -> IO RuntimeTerm
eval rws t0 =
  do
    result <- mapM (apply t0) (S.toList rws)
    case S.toList $ S.unions result of
      []      -> return t0
      (t : _) -> eval rws t

rewrites ::
    (Show oc, Hashable oc, Eq oc) =>
    OCAlgebra oc RuntimeTerm IO ->
    S.HashSet Rewrite ->
    S.HashSet Rewrite ->
    RuntimeTerm ->
    IO (S.HashSet RuntimeTerm)
rewrites impl evalRWs userRWs t0 =
    resultTerms . fst
        <$> rest
            RESTParams
                { re = evalRWs
                , ru = userRWs
                , target = Nothing
                , workStrategy = notVisitedFirst
                , ocImpl = ?impl
                , initRes = termsResult
                , etStrategy = ExploreWhenNeeded
                }
            t0
  where
    ?impl = impl

proveEQ ::
    (Show oc, Hashable oc, Eq oc) =>
    OCAlgebra oc RuntimeTerm IO ->
    S.HashSet Rewrite ->
    S.HashSet Rewrite ->
    RuntimeTerm ->
    RuntimeTerm ->
    IO Bool
proveEQ impl evalRWs userRWs have want =
    do
        rw1 <- rewrites impl evalRWs userRWs have
        not . disjoint rw1 <$> rewrites impl evalRWs userRWs want
  where
    disjoint s1 s2 = S.null $ s1 `S.intersection` s2
